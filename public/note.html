<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Note Editor - Research Notebook</title>
  <link rel="stylesheet" href="/styles.css">
  <!-- Markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked@11.0.0/marked.min.js"></script>
  <!-- Syntax highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css">
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
</head>
<body>
  <div class="container">
    <header class="site-header">
      <div class="brand">
        <div class="logo">RN</div>
        <div>
          <h1>Note Editor</h1>
          <p class="lead">Write and preview markdown notes</p>
        </div>
      </div>
      <nav class="nav">
        <a href="/">Home</a>
        <a href="/todos.html">Todos</a>
        <a href="/dashboard.html">Dashboard</a>
        <span id="auth-actions"></span>
      </nav>
    </header>

    <div class="card">
      <div class="note-meta">
        <input id="note-title-input" class="note-title-input" placeholder="Note title..." />
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="save-note" class="btn btn-primary">Save Note</button>
          <button id="use-template-btn" class="btn btn-secondary">üìÑ Use Template</button>
          <button id="save-as-template-btn" class="btn btn-secondary" style="display:none">üíæ Save as Template</button>
          <button id="export-note" class="btn btn-secondary" style="display:none">üì• Export .md</button>
          <button id="delete-note" class="btn btn-danger" style="display:none">Delete</button>
          <a id="cancel-link" href="/" class="btn btn-secondary">Cancel</a>
        </div>
      </div>
      
      <div id="note-meta-info" class="muted small" style="margin-bottom:16px"></div>
      
      <div class="editor-toolbar">
        <button id="tb-bold" class="btn btn-sm btn-secondary"><strong>B</strong></button>
        <button id="tb-italic" class="btn btn-sm btn-secondary"><em>I</em></button>
        <button id="tb-h1" class="btn btn-sm btn-secondary">H1</button>
        <button id="tb-code" class="btn btn-sm btn-secondary">Code</button>
        <button id="tb-image" class="btn btn-sm btn-secondary">üì∑ Image</button>
        <input type="file" id="image-upload" accept="image/*" style="display:none" />
        <button id="toggle-preview" class="btn btn-sm btn-secondary">Toggle Preview</button>
        <span class="editor-status" id="editor-status">Ready</span>
        <span class="realtime-status" id="realtime-status" title="Real-time connection status">‚óè</span>
      </div>
      
      <div class="note-editor">
        <textarea id="note-body" placeholder="Write your markdown here..."></textarea>
        <div class="note-preview" id="note-preview"></div>
      </div>
    </div>
  </div>

  <!-- Template Picker Modal -->
  <div id="template-modal-overlay" class="modal-overlay hidden" style="display:none;">
    <div class="modal" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
      <h3>Choose a Template</h3>
      <div id="templates-list" class="templates-grid" style="margin: 20px 0;">
        <!-- Templates will be loaded here -->
      </div>
      <div class="modal-actions">
        <button type="button" class="btn btn-secondary" id="template-modal-cancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Save Template Modal -->
  <div id="save-template-modal" class="modal-overlay hidden" style="display:none;">
    <div class="modal">
      <h3>Save as Template</h3>
      <form id="save-template-form">
        <div>
          <label for="template-name">Template Name</label>
          <input id="template-name" type="text" required placeholder="My Template" />
        </div>
        <div>
          <label for="template-description">Description (optional)</label>
          <input id="template-description" type="text" placeholder="Describe what this template is for..." />
        </div>
        <div>
          <label for="template-icon">Icon (optional)</label>
          <input id="template-icon" type="text" placeholder="üìÑ" maxlength="2" />
        </div>
        <div class="modal-actions">
          <button type="button" class="btn btn-secondary" id="save-template-cancel">Cancel</button>
          <button type="submit" class="btn btn-primary">Save Template</button>
        </div>
      </form>
    </div>
  </div>

  <script src="/app.js"></script>
  <script>
    function qs(name){ const u=new URL(location.href); return u.searchParams.get(name); }
    const noteId = qs('id');
    const projectId = qs('projectId');

    // autosave draft to localStorage (debounced)
    let autosaveTimeout = null;
    let realtimeEventSource = null;
    
    function draftKey() { return 'draft_note_' + (noteId || projectId || 'anon'); }
    function saveDraftToLocal(){
      const key = draftKey();
      const payload = { title: document.getElementById('note-title-input').value||'', body: document.getElementById('note-body').value||'', ts: Date.now() };
      try { localStorage.setItem(key, JSON.stringify(payload)); } catch(e){}
      if (window.showToast) showToast('Draft saved', 'success', 900);
      const status = document.getElementById('editor-status'); if(status) status.textContent = 'Draft saved';
    }

    // Real-time updates connection
    function setupRealtimeUpdates() {
      const statusEl = document.getElementById('realtime-status');
      
      function updateStatus(state) {
        statusEl.className = 'realtime-status ' + state;
        if (state === 'connected') {
          statusEl.title = 'Connected - receiving live updates';
        } else if (state === 'connecting') {
          statusEl.title = 'Connecting...';
        } else {
          statusEl.title = 'Disconnected - will retry';
        }
      }
      
      function connect() {
        if (realtimeEventSource) {
          realtimeEventSource.close();
        }
        
        updateStatus('connecting');
        
        realtimeEventSource = new EventSource('/api/realtime/updates');
        
        realtimeEventSource.onopen = () => {
          updateStatus('connected');
        };
        
        realtimeEventSource.addEventListener('note-updated', (e) => {
          try {
            const data = JSON.parse(e.data);
            // Only reload if it's the current note and we're not actively editing
            if (noteId && data.noteId === noteId) {
              const bodyEl = document.getElementById('note-body');
              const titleEl = document.getElementById('note-title-input');
              const isEditing = document.activeElement === bodyEl || document.activeElement === titleEl;
              
              if (!isEditing) {
                showToast('Note updated by another user - reloading', 'info', 2000);
                setTimeout(() => loadNote(), 500);
              } else {
                showToast('Note updated by another user (not reloading while you edit)', 'warning', 3000);
              }
            }
          } catch (err) {
            console.error('Error handling note-updated event:', err);
          }
        });
        
        realtimeEventSource.onerror = () => {
          updateStatus('disconnected');
          realtimeEventSource.close();
          // Retry connection after 5 seconds
          setTimeout(connect, 5000);
        };
      }
      
      connect();
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        if (realtimeEventSource) {
          realtimeEventSource.close();
        }
      });
    }

    async function init(){
      renderAuthActions();
      
      // Configure marked.js with syntax highlighting
      if (window.marked) {
        marked.setOptions({
          highlight: function(code, lang) {
            if (lang && hljs.getLanguage(lang)) {
              try {
                return hljs.highlight(code, { language: lang }).value;
              } catch (err) {}
            }
            return hljs.highlightAuto(code).value;
          },
          breaks: true,
          gfm: true
        });
      }
      
      const bodyEl = document.getElementById('note-body');
      bodyEl.addEventListener('input', ()=>{
        const v = bodyEl.value;
        const preview = document.getElementById('note-preview');
        if (window.marked) {
          let html = marked.parse(v);
          // Highlight @mentions
          html = html.replace(/@([\w.+-]+@[\w.-]+|[\w]+)/g, '<span class="mention">@$1</span>');
          preview.innerHTML = html;
          // Apply syntax highlighting to code blocks
          preview.querySelectorAll('pre code').forEach((block) => {
            hljs.highlightElement(block);
          });
        } else {
          preview.innerHTML = escapeHtml(v);
        }
        const status = document.getElementById('editor-status'); if(status) status.textContent = 'Editing...';
        clearTimeout(autosaveTimeout); autosaveTimeout = setTimeout(saveDraftToLocal, 1200);
      });
      
      // Drag and drop for images
      bodyEl.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        bodyEl.style.borderColor = '#4f46e5';
        bodyEl.style.backgroundColor = 'rgba(79, 70, 229, 0.05)';
      });
      
      bodyEl.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        bodyEl.style.borderColor = '';
        bodyEl.style.backgroundColor = '';
      });
      
      bodyEl.addEventListener('drop', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        bodyEl.style.borderColor = '';
        bodyEl.style.backgroundColor = '';
        
        const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
        if (files.length === 0) return;
        
        for (const file of files) {
          try {
            const result = await uploadImage(file);
            if (result && result.url) {
              insertImageMarkdown(result.url, result.filename || file.name);
            }
          } catch (err) {
            // Error already handled in uploadImage
          }
        }
      });
      
      // toolbar actions
      document.getElementById('tb-bold').addEventListener('click', ()=> wrapSelection(bodyEl, '**'));
      document.getElementById('tb-italic').addEventListener('click', ()=> wrapSelection(bodyEl, '*'));
      document.getElementById('tb-h1').addEventListener('click', ()=> prependLine(bodyEl, '# '));
      document.getElementById('tb-code').addEventListener('click', ()=> wrapSelection(bodyEl, '```\n', '\n```'));
      
      // Image upload button
      const imageBtn = document.getElementById('tb-image');
      const imageInput = document.getElementById('image-upload');
      imageBtn.addEventListener('click', () => imageInput.click());
      imageInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
          const result = await uploadImage(file);
          if (result && result.url) {
            insertImageMarkdown(result.url, result.filename || file.name);
          }
        } catch (err) {
          // Error already handled in uploadImage
        }
        // Reset input so same file can be uploaded again
        e.target.value = '';
      });
      
      document.getElementById('toggle-preview').addEventListener('click', ()=>{ document.getElementById('note-preview').classList.toggle('hidden'); });
      document.getElementById('save-note').addEventListener('click', save);
      
      // Template buttons
      document.getElementById('use-template-btn').addEventListener('click', openTemplateModal);
      document.getElementById('template-modal-cancel').addEventListener('click', closeTemplateModal);
      
      // Save as template (show button when editing existing note)
      if (noteId) {
        document.getElementById('save-as-template-btn').style.display = 'inline-block';
      }
      document.getElementById('save-as-template-btn').addEventListener('click', openSaveTemplateModal);
      document.getElementById('save-template-cancel').addEventListener('click', closeSaveTemplateModal);
      document.getElementById('save-template-form').addEventListener('submit', saveAsTemplate);
      
      // restore draft if present
      const draftRaw = localStorage.getItem(draftKey());
      if (draftRaw) {
        try {
          const d = JSON.parse(draftRaw);
          if (d && (d.body || d.title)) {
            if (confirm('Restore unsaved draft from ' + new Date(d.ts).toLocaleString() + '?')) {
              document.getElementById('note-title-input').value = d.title || '';
              document.getElementById('note-body').value = d.body || '';
              document.getElementById('note-body').dispatchEvent(new Event('input'));
            }
          }
        } catch(e) { /* ignore */ }
      }
      if (noteId) await loadNote();
      
      // Set cancel link to go back to appropriate location
      if (projectId) {
        document.getElementById('cancel-link').href = '/project.html?id=' + encodeURIComponent(projectId);
      } else if (document.referrer && document.referrer.includes(window.location.origin)) {
        // Make cancel go back if there's a referrer from our site
        document.getElementById('cancel-link').addEventListener('click', (e) => {
          e.preventDefault();
          history.back();
        });
      } else {
        document.getElementById('cancel-link').href = '/notes.html';
      }
      
      // Setup real-time updates after loading note
      setupRealtimeUpdates();
    }

    async function loadNote(){
      try{
        const n = await api.request('/api/notes?id=' + encodeURIComponent(noteId));
        document.getElementById('note-title-input').value = n.title || '';
        document.getElementById('note-body').value = n.bodyMarkdown || '';
        document.getElementById('note-body').dispatchEvent(new Event('input'));
        // show meta
        const meta = document.getElementById('note-meta-info');
        meta.textContent = 'Author: ' + (n.authorId || '-') + ' ¬∑ Created: ' + (n.createdAt? new Date(n.createdAt).toLocaleString() : '-') + (n.updatedAt?(' ¬∑ Updated: '+new Date(n.updatedAt).toLocaleString()):'');
        
        // show export button
        const exportBtn = document.getElementById('export-note');
        if(exportBtn) {
          exportBtn.style.display = 'inline-block';
          exportBtn.addEventListener('click', () => exportAsMarkdown(n.title, n.bodyMarkdown));
        }
        
        // show delete button (API will enforce permission)
        const del = document.getElementById('delete-note'); 
        if(del) { 
          del.style.display='inline-block'; 
          del.addEventListener('click', async ()=>{
            const confirmed = await confirmDialog('Delete this note?', 'This action cannot be undone.');
            if(!confirmed) return; 
            try{ 
              await api.request('/api/notes?id='+encodeURIComponent(noteId), { method:'DELETE' }); 
              showToast('Deleted','success'); 
              location.href = '/dashboard.html';
            }catch(e){ 
              showToast('Delete failed: '+(e.error||JSON.stringify(e)),'error',3000); 
            }
          }); 
        }
      }catch(e){ 
        if(window.showToast) showToast('Unable to load note: ' + (e.error || 'Network error'), 'error', 3000); 
      }
    }
    
    function exportAsMarkdown(title, body) {
      const filename = (title || 'note').replace(/[^a-z0-9]/gi, '_').toLowerCase() + '.md';
      const content = `# ${title || 'Untitled Note'}\n\n${body || ''}`;
      const blob = new Blob([content], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast('Note exported as ' + filename, 'success', 2000);
    }

    async function save(){
      const title = document.getElementById('note-title-input').value;
      const body = document.getElementById('note-body').value;
      
      if (!title || !title.trim()) {
        showToast('Please enter a title for your note', 'error', 2000);
        document.getElementById('note-title-input').focus();
        return;
      }
      
      try{
        if (noteId) {
          // Updating existing note
          await api.request('/api/notes?id=' + encodeURIComponent(noteId), { method: 'PATCH', body: { title, bodyMarkdown: body } });
          showToast('Note saved successfully!', 'success', 1500);
          try{ localStorage.removeItem(draftKey()); }catch(e){}
          
          // Navigate back to where user came from
          if (projectId) {
            // If editing from project, go back to project
            setTimeout(() => window.location.href = '/project.html?id=' + encodeURIComponent(projectId), 500);
          } else if (document.referrer && document.referrer.includes(window.location.origin)) {
            // Go back to previous page if it's from our site
            setTimeout(() => history.back(), 500);
          } else {
            // Default to notes list
            setTimeout(() => window.location.href = '/notes.html', 500);
          }
          return;
        }
        
        // Creating new note
        const payload = { title, bodyMarkdown: body };
        if (projectId) payload.projectId = projectId;
        const res = await api.request('/api/notes', { method: 'POST', body: payload });
        showToast('Note created successfully!', 'success', 1500);
        try{ localStorage.removeItem(draftKey()); }catch(e){}
        
        // Navigate to appropriate location after creation
        if (projectId) {
          // If created from project, go back to project
          setTimeout(() => window.location.href = '/project.html?id=' + encodeURIComponent(projectId), 500);
        } else {
          // Otherwise go to notes list
          setTimeout(() => window.location.href = '/notes.html', 500);
        }
        location.href = '/dashboard.html';
      }catch(e){ 
        const errorMsg = e.userMessage || e.error || 'Failed to save note';
        showToast(errorMsg, 'error', 3000);
      }
    }

    // Image upload functionality
    async function uploadImage(file) {
      const maxSize = 5 * 1024 * 1024; // 5MB
      if (file.size > maxSize) {
        showToast('Image must be less than 5MB', 'error', 3000);
        return null;
      }

      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const statusEl = document.getElementById('editor-status');
            statusEl.textContent = 'Uploading image...';
            
            const payload = {
              image: e.target.result,
              filename: file.name,
              noteId: noteId || null
            };
            
            const res = await api.request('/api/uploads/images', { 
              method: 'POST', 
              body: payload 
            });
            
            statusEl.textContent = 'Ready';
            showToast('Image uploaded successfully!', 'success', 1500);
            resolve(res);
          } catch (err) {
            const statusEl = document.getElementById('editor-status');
            statusEl.textContent = 'Ready';
            const errorMsg = err.userMessage || err.error || 'Failed to upload image';
            showToast(errorMsg, 'error', 3000);
            reject(err);
          }
        };
        reader.onerror = () => {
          showToast('Failed to read image file', 'error', 3000);
          reject(new Error('File read error'));
        };
        reader.readAsDataURL(file);
      });
    }

    function insertImageMarkdown(imageUrl, filename) {
      const textarea = document.getElementById('note-body');
      const altText = filename.replace(/\.[^/.]+$/, ''); // Remove extension
      const markdown = `![${altText}](${imageUrl})`;
      
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const val = textarea.value;
      
      textarea.value = val.slice(0, start) + markdown + val.slice(end);
      textarea.focus();
      textarea.selectionStart = textarea.selectionEnd = start + markdown.length;
      textarea.dispatchEvent(new Event('input'));
    }

  function wrapSelection(el, before, after){ if(typeof after==='undefined') after=before; const start=el.selectionStart, end=el.selectionEnd; const val=el.value; const selected=val.slice(start,end); el.value = val.slice(0,start)+before+selected+after+val.slice(end); el.focus(); el.selectionStart = start + before.length; el.selectionEnd = end + before.length; el.dispatchEvent(new Event('input')); }
  function prependLine(el, prefix){ const start=el.selectionStart, val=el.value; const lineStart = val.lastIndexOf('\n', start-1)+1; el.value = val.slice(0,lineStart)+prefix+val.slice(lineStart); el.focus(); el.dispatchEvent(new Event('input')); }

    // Template Functions
    async function openTemplateModal() {
      const overlay = document.getElementById('template-modal-overlay');
      const listEl = document.getElementById('templates-list');
      
      overlay.classList.remove('hidden');
      overlay.style.display = 'flex';
      
      listEl.innerHTML = '<div class="center" style="padding: 40px;"><div class="spinner"></div><p>Loading templates...</p></div>';
      
      try {
        const templates = await api.request('/api/templates');
        
        if (!templates || templates.length === 0) {
          listEl.innerHTML = '<div class="muted center" style="padding: 40px;">No templates available</div>';
          return;
        }
        
        listEl.innerHTML = templates.map(t => `
          <div class="template-card" onclick="applyTemplate('${t._id}')" style="cursor: pointer; padding: 16px; border: 1px solid var(--border); border-radius: var(--radius-md); background: var(--surface); transition: all 0.2s;">
            <div style="font-size: 32px; margin-bottom: 8px;">${t.icon || 'üìÑ'}</div>
            <h4 style="margin-bottom: 4px;">${escapeHtml(t.name)}</h4>
            <p class="muted small" style="margin-bottom: 8px;">${escapeHtml(t.description || '')}</p>
            ${t.tags && t.tags.length ? `<div class="tags-container">${t.tags.map(tag => `<span class="tag">${escapeHtml(tag)}</span>`).join('')}</div>` : ''}
          </div>
        `).join('');
        
        // Add hover effect
        document.querySelectorAll('.template-card').forEach(card => {
          card.addEventListener('mouseenter', () => {
            card.style.borderColor = 'var(--accent)';
            card.style.transform = 'translateY(-2px)';
          });
          card.addEventListener('mouseleave', () => {
            card.style.borderColor = 'var(--border)';
            card.style.transform = 'translateY(0)';
          });
        });
      } catch (err) {
        console.error('Failed to load templates:', err);
        const errorMsg = err.userMessage || err.error || 'Failed to load templates';
        listEl.innerHTML = `
          <div class="muted center" style="padding: 40px;">
            <div style="font-size: 48px; margin-bottom: 16px;">üòï</div>
            <div>${escapeHtml(errorMsg)}</div>
            <div style="font-size: 13px; margin-top: 8px;">
              ${err.status === 401 ? 'Please try signing out and back in.' : 'Please try again later.'}
            </div>
          </div>
        `;
      }
    }
    
    function closeTemplateModal() {
      const overlay = document.getElementById('template-modal-overlay');
      overlay.classList.add('hidden');
      overlay.style.display = 'none';
    }
    
    async function applyTemplate(templateId) {
      try {
        const templates = await api.request('/api/templates');
        const template = templates.find(t => t._id === templateId);
        
        if (!template) {
          showToast('Template not found', 'error');
          return;
        }
        
        // Confirm if there's existing content
        const titleInput = document.getElementById('note-title-input');
        const bodyInput = document.getElementById('note-body');
        const hasContent = titleInput.value.trim() || bodyInput.value.trim();
        
        if (hasContent) {
          if (!confirm('This will replace your current content. Continue?')) {
            return;
          }
        }
        
        // Apply template
        titleInput.value = template.name;
        bodyInput.value = template.content;
        bodyInput.dispatchEvent(new Event('input'));
        
        closeTemplateModal();
        showToast('Template applied!', 'success', 1500);
      } catch (err) {
        console.error('Failed to apply template:', err);
        showToast('Failed to apply template', 'error');
      }
    }
    
    function openSaveTemplateModal() {
      const titleInput = document.getElementById('note-title-input');
      const bodyInput = document.getElementById('note-body');
      
      if (!titleInput.value.trim() || !bodyInput.value.trim()) {
        showToast('Please add a title and content first', 'error', 2000);
        return;
      }
      
      const overlay = document.getElementById('save-template-modal');
      overlay.classList.remove('hidden');
      overlay.style.display = 'flex';
      
      // Pre-fill template name with note title
      document.getElementById('template-name').value = titleInput.value;
      document.getElementById('template-name').focus();
    }
    
    function closeSaveTemplateModal() {
      const overlay = document.getElementById('save-template-modal');
      overlay.classList.add('hidden');
      overlay.style.display = 'none';
      document.getElementById('save-template-form').reset();
    }
    
    async function saveAsTemplate(e) {
      e.preventDefault();
      
      const name = document.getElementById('template-name').value.trim();
      const description = document.getElementById('template-description').value.trim();
      const icon = document.getElementById('template-icon').value.trim() || 'üìÑ';
      const content = document.getElementById('note-body').value;
      
      if (!name || !content) {
        showToast('Name and content are required', 'error');
        return;
      }
      
      try {
        await api.request('/api/templates', {
          method: 'POST',
          body: {
            name,
            description,
            icon,
            content,
            type: 'note',
            tags: []
          }
        });
        
        closeSaveTemplateModal();
        showToast('Template saved successfully!', 'success', 1500);
      } catch (err) {
        console.error('Failed to save template:', err);
        showToast(err.userMessage || 'Failed to save template', 'error');
      }
    }
    
    // Make functions globally accessible
    window.applyTemplate = applyTemplate;

    // load marked.js from CDN for markdown preview if not present
    (function(){
      if (window.marked) return init();
      const s = document.createElement('script'); s.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js'; s.onload = init; document.head.appendChild(s);
    })();
  </script>
</body>
</html>
