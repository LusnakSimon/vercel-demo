<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Note Editor</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <header class="site-header">
    <a href="/">Research Notebook</a>
    <nav id="auth-actions" style="float:right"></nav>
  </header>
  <main class="container">
    <h1 id="note-title">Note</h1>
    <div class="row">
      <input id="note-title-input" placeholder="Note title" style="flex:1;margin-right:8px" />
      <div style="display:flex;gap:8px;align-items:center">
        <button id="save-note" class="btn">Save</button>
        <button id="delete-note" class="btn secondary" style="display:none">Delete</button>
        <a id="cancel-link" href="/" class="btn secondary" style="margin-left:8px">Cancel</a>
      </div>
    </div>
    <div id="note-meta" class="muted small" style="margin-top:8px"></div>
    <div style="display:flex;gap:12px;margin-top:12px">
      <textarea id="note-body" style="flex:1;min-height:320px" placeholder="Write markdown here..."></textarea>
      <div style="flex:1;min-height:320px;border:1px solid var(--muted);padding:12px;overflow:auto;background:#fff" id="note-preview"></div>
    </div>
  </main>
  <script src="/app.js"></script>
  <script>
    function qs(name){ const u=new URL(location.href); return u.searchParams.get(name); }
    const noteId = qs('id');
    const projectId = qs('projectId');

    // autosave draft to localStorage (debounced)
    let autosaveTimeout = null;
    function draftKey() { return 'draft_note_' + (noteId || projectId || 'anon'); }
    function saveDraftToLocal(){
      const key = draftKey();
      const payload = { title: document.getElementById('note-title-input').value||'', body: document.getElementById('note-body').value||'', ts: Date.now() };
      try { localStorage.setItem(key, JSON.stringify(payload)); } catch(e){}
      if (window.showToast) showToast('Draft saved', 'success', 900);
      const status = document.getElementById('editor-status'); if(status) status.textContent = 'Draft saved';
    }

    async function init(){
      renderAuthActions();
      const bodyEl = document.getElementById('note-body');
      bodyEl.addEventListener('input', ()=>{
        const v = bodyEl.value;
        document.getElementById('note-preview').innerHTML = window.marked ? window.marked.parse(v) : escapeHtml(v);
        const status = document.getElementById('editor-status'); if(status) status.textContent = 'Editing...';
        clearTimeout(autosaveTimeout); autosaveTimeout = setTimeout(saveDraftToLocal, 1200);
      });
      document.getElementById('save-note').addEventListener('click', save);
      // restore draft if present
      const draftRaw = localStorage.getItem(draftKey());
      if (draftRaw) {
        try {
          const d = JSON.parse(draftRaw);
          if (d && (d.body || d.title)) {
            if (confirm('Restore unsaved draft from ' + new Date(d.ts).toLocaleString() + '?')) {
              document.getElementById('note-title-input').value = d.title || '';
              document.getElementById('note-body').value = d.body || '';
              document.getElementById('note-body').dispatchEvent(new Event('input'));
            }
          }
        } catch(e) { /* ignore */ }
      }
      if (noteId) await loadNote();
      if (projectId) document.getElementById('cancel-link').href = '/project-notes.html?projectId=' + encodeURIComponent(projectId);
    }

    async function loadNote(){
      try{
        const n = await api.request('/api/notes?id=' + encodeURIComponent(noteId));
        document.getElementById('note-title-input').value = n.title || '';
        document.getElementById('note-body').value = n.bodyMarkdown || '';
        document.getElementById('note-body').dispatchEvent(new Event('input'));
        // show meta
        const meta = document.getElementById('note-meta');
        meta.textContent = 'Author: ' + (n.authorId || '-') + ' · Created: ' + (n.createdAt? new Date(n.createdAt).toLocaleString() : '-') + (n.updatedAt?(' · Updated: '+new Date(n.updatedAt).toLocaleString()):'');
        // show delete button (API will enforce permission)
        const del = document.getElementById('delete-note'); if(del) { del.style.display='inline-block'; del.addEventListener('click', async ()=>{
          if(!confirm('Delete this note?')) return; try{ await api.request('/api/notes?id='+encodeURIComponent(noteId), { method:'DELETE' }); showToast('Deleted','success'); location.href = '/project-notes.html?projectId=' + encodeURIComponent(projectId || ''); }catch(e){ showToast('Delete failed: '+(e.error||JSON.stringify(e)),'error',3000); }
        }); }
      }catch(e){ if(window.showToast) showToast('Unable to load note', 'error', 2200); }
    }

    async function save(){
      const title = document.getElementById('note-title-input').value;
      const body = document.getElementById('note-body').value;
      try{
        if (noteId) {
          await api.request('/api/notes?id=' + encodeURIComponent(noteId), { method: 'PATCH', body: { title, bodyMarkdown: body } });
          if(window.showToast) showToast('Saved', 'success', 1200);
          try{ localStorage.removeItem(draftKey()); }catch(e){}
          history.back();
          return;
        }
        const payload = { title, bodyMarkdown: body };
        if (projectId) payload.projectId = projectId;
        const res = await api.request('/api/notes', { method: 'POST', body: payload });
        if(window.showToast) showToast('Created', 'success', 1200);
        try{ localStorage.removeItem(draftKey()); }catch(e){}
        location.href = '/project-notes.html?projectId=' + encodeURIComponent(res.projectId || projectId || '');
      }catch(e){ if(window.showToast) showToast('Save failed: ' + (e.error||JSON.stringify(e)), 'error', 3000); }
    }

    // load marked.js from CDN for markdown preview if not present
    (function(){
      if (window.marked) return init();
      const s = document.createElement('script'); s.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js'; s.onload = init; document.head.appendChild(s);
    })();
  </script>
</body>
</html>
