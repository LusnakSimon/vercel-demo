<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Note Editor - Research Notebook</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <div class="container">
    <header class="site-header">
      <div class="brand">
        <div class="logo">RN</div>
        <div>
          <h1>Note Editor</h1>
          <p class="lead">Write and preview markdown notes</p>
        </div>
      </div>
      <nav class="nav">
        <a href="/">Home</a>
        <a href="/todos.html">Todos</a>
        <a href="/dashboard.html">Dashboard</a>
        <span id="auth-actions"></span>
      </nav>
    </header>

    <div class="card">
      <div class="note-meta">
        <input id="note-title-input" class="note-title-input" placeholder="Note title..." />
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="save-note" class="btn btn-primary">Save Note</button>
          <button id="export-note" class="btn btn-secondary" style="display:none">üì• Export .md</button>
          <button id="delete-note" class="btn btn-danger" style="display:none">Delete</button>
          <a id="cancel-link" href="/" class="btn btn-secondary">Cancel</a>
        </div>
      </div>
      
      <div id="note-meta-info" class="muted small" style="margin-bottom:16px"></div>
      
      <div class="editor-toolbar">
        <button id="tb-bold" class="btn btn-sm btn-secondary"><strong>B</strong></button>
        <button id="tb-italic" class="btn btn-sm btn-secondary"><em>I</em></button>
        <button id="tb-h1" class="btn btn-sm btn-secondary">H1</button>
        <button id="tb-code" class="btn btn-sm btn-secondary">Code</button>
        <button id="tb-image" class="btn btn-sm btn-secondary">üì∑ Image</button>
        <input type="file" id="image-upload" accept="image/*" style="display:none" />
        <button id="toggle-preview" class="btn btn-sm btn-secondary">Toggle Preview</button>
        <span class="editor-status" id="editor-status">Ready</span>
        <span class="realtime-status" id="realtime-status" title="Real-time connection status">‚óè</span>
      </div>
      
      <div class="note-editor">
        <textarea id="note-body" placeholder="Write your markdown here..."></textarea>
        <div class="note-preview" id="note-preview"></div>
      </div>
    </div>
  </div>

  <script src="/app.js"></script>
  <script>
    function qs(name){ const u=new URL(location.href); return u.searchParams.get(name); }
    const noteId = qs('id');
    const projectId = qs('projectId');

    // autosave draft to localStorage (debounced)
    let autosaveTimeout = null;
    let realtimeEventSource = null;
    
    function draftKey() { return 'draft_note_' + (noteId || projectId || 'anon'); }
    function saveDraftToLocal(){
      const key = draftKey();
      const payload = { title: document.getElementById('note-title-input').value||'', body: document.getElementById('note-body').value||'', ts: Date.now() };
      try { localStorage.setItem(key, JSON.stringify(payload)); } catch(e){}
      if (window.showToast) showToast('Draft saved', 'success', 900);
      const status = document.getElementById('editor-status'); if(status) status.textContent = 'Draft saved';
    }

    // Real-time updates connection
    function setupRealtimeUpdates() {
      const statusEl = document.getElementById('realtime-status');
      
      function updateStatus(state) {
        statusEl.className = 'realtime-status ' + state;
        if (state === 'connected') {
          statusEl.title = 'Connected - receiving live updates';
        } else if (state === 'connecting') {
          statusEl.title = 'Connecting...';
        } else {
          statusEl.title = 'Disconnected - will retry';
        }
      }
      
      function connect() {
        if (realtimeEventSource) {
          realtimeEventSource.close();
        }
        
        updateStatus('connecting');
        
        realtimeEventSource = new EventSource('/api/realtime/updates');
        
        realtimeEventSource.onopen = () => {
          updateStatus('connected');
        };
        
        realtimeEventSource.addEventListener('note-updated', (e) => {
          try {
            const data = JSON.parse(e.data);
            // Only reload if it's the current note and we're not actively editing
            if (noteId && data.noteId === noteId) {
              const bodyEl = document.getElementById('note-body');
              const titleEl = document.getElementById('note-title-input');
              const isEditing = document.activeElement === bodyEl || document.activeElement === titleEl;
              
              if (!isEditing) {
                showToast('Note updated by another user - reloading', 'info', 2000);
                setTimeout(() => loadNote(), 500);
              } else {
                showToast('Note updated by another user (not reloading while you edit)', 'warning', 3000);
              }
            }
          } catch (err) {
            console.error('Error handling note-updated event:', err);
          }
        });
        
        realtimeEventSource.onerror = () => {
          updateStatus('disconnected');
          realtimeEventSource.close();
          // Retry connection after 5 seconds
          setTimeout(connect, 5000);
        };
      }
      
      connect();
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        if (realtimeEventSource) {
          realtimeEventSource.close();
        }
      });
    }

    async function init(){
      renderAuthActions();
      const bodyEl = document.getElementById('note-body');
      bodyEl.addEventListener('input', ()=>{
        const v = bodyEl.value;
        document.getElementById('note-preview').innerHTML = window.marked ? window.marked.parse(v) : escapeHtml(v);
        const status = document.getElementById('editor-status'); if(status) status.textContent = 'Editing...';
        clearTimeout(autosaveTimeout); autosaveTimeout = setTimeout(saveDraftToLocal, 1200);
      });
      
      // Drag and drop for images
      bodyEl.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        bodyEl.style.borderColor = '#4f46e5';
        bodyEl.style.backgroundColor = 'rgba(79, 70, 229, 0.05)';
      });
      
      bodyEl.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        bodyEl.style.borderColor = '';
        bodyEl.style.backgroundColor = '';
      });
      
      bodyEl.addEventListener('drop', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        bodyEl.style.borderColor = '';
        bodyEl.style.backgroundColor = '';
        
        const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
        if (files.length === 0) return;
        
        for (const file of files) {
          try {
            const result = await uploadImage(file);
            if (result && result.url) {
              insertImageMarkdown(result.url, result.filename || file.name);
            }
          } catch (err) {
            // Error already handled in uploadImage
          }
        }
      });
      
      // toolbar actions
      document.getElementById('tb-bold').addEventListener('click', ()=> wrapSelection(bodyEl, '**'));
      document.getElementById('tb-italic').addEventListener('click', ()=> wrapSelection(bodyEl, '*'));
      document.getElementById('tb-h1').addEventListener('click', ()=> prependLine(bodyEl, '# '));
      document.getElementById('tb-code').addEventListener('click', ()=> wrapSelection(bodyEl, '```\n', '\n```'));
      
      // Image upload button
      const imageBtn = document.getElementById('tb-image');
      const imageInput = document.getElementById('image-upload');
      imageBtn.addEventListener('click', () => imageInput.click());
      imageInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
          const result = await uploadImage(file);
          if (result && result.url) {
            insertImageMarkdown(result.url, result.filename || file.name);
          }
        } catch (err) {
          // Error already handled in uploadImage
        }
        // Reset input so same file can be uploaded again
        e.target.value = '';
      });
      
      document.getElementById('toggle-preview').addEventListener('click', ()=>{ document.getElementById('note-preview').classList.toggle('hidden'); });
      document.getElementById('save-note').addEventListener('click', save);
      // restore draft if present
      const draftRaw = localStorage.getItem(draftKey());
      if (draftRaw) {
        try {
          const d = JSON.parse(draftRaw);
          if (d && (d.body || d.title)) {
            if (confirm('Restore unsaved draft from ' + new Date(d.ts).toLocaleString() + '?')) {
              document.getElementById('note-title-input').value = d.title || '';
              document.getElementById('note-body').value = d.body || '';
              document.getElementById('note-body').dispatchEvent(new Event('input'));
            }
          }
        } catch(e) { /* ignore */ }
      }
      if (noteId) await loadNote();
      if (projectId) document.getElementById('cancel-link').href = '/project-notes.html?projectId=' + encodeURIComponent(projectId);
      
      // Setup real-time updates after loading note
      setupRealtimeUpdates();
    }

    async function loadNote(){
      try{
        const n = await api.request('/api/notes?id=' + encodeURIComponent(noteId));
        document.getElementById('note-title-input').value = n.title || '';
        document.getElementById('note-body').value = n.bodyMarkdown || '';
        document.getElementById('note-body').dispatchEvent(new Event('input'));
        // show meta
        const meta = document.getElementById('note-meta-info');
        meta.textContent = 'Author: ' + (n.authorId || '-') + ' ¬∑ Created: ' + (n.createdAt? new Date(n.createdAt).toLocaleString() : '-') + (n.updatedAt?(' ¬∑ Updated: '+new Date(n.updatedAt).toLocaleString()):'');
        
        // show export button
        const exportBtn = document.getElementById('export-note');
        if(exportBtn) {
          exportBtn.style.display = 'inline-block';
          exportBtn.addEventListener('click', () => exportAsMarkdown(n.title, n.bodyMarkdown));
        }
        
        // show delete button (API will enforce permission)
        const del = document.getElementById('delete-note'); 
        if(del) { 
          del.style.display='inline-block'; 
          del.addEventListener('click', async ()=>{
            const confirmed = await confirmDialog('Delete this note?', 'This action cannot be undone.');
            if(!confirmed) return; 
            try{ 
              await api.request('/api/notes?id='+encodeURIComponent(noteId), { method:'DELETE' }); 
              showToast('Deleted','success'); 
              location.href = '/dashboard.html';
            }catch(e){ 
              showToast('Delete failed: '+(e.error||JSON.stringify(e)),'error',3000); 
            }
          }); 
        }
      }catch(e){ 
        if(window.showToast) showToast('Unable to load note: ' + (e.error || 'Network error'), 'error', 3000); 
      }
    }
    
    function exportAsMarkdown(title, body) {
      const filename = (title || 'note').replace(/[^a-z0-9]/gi, '_').toLowerCase() + '.md';
      const content = `# ${title || 'Untitled Note'}\n\n${body || ''}`;
      const blob = new Blob([content], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast('Note exported as ' + filename, 'success', 2000);
    }

    async function save(){
      const title = document.getElementById('note-title-input').value;
      const body = document.getElementById('note-body').value;
      
      if (!title || !title.trim()) {
        showToast('Please enter a title for your note', 'error', 2000);
        document.getElementById('note-title-input').focus();
        return;
      }
      
      try{
        if (noteId) {
          await api.request('/api/notes?id=' + encodeURIComponent(noteId), { method: 'PATCH', body: { title, bodyMarkdown: body } });
          showToast('Note saved successfully!', 'success', 1500);
          try{ localStorage.removeItem(draftKey()); }catch(e){}
          history.back();
          return;
        }
        const payload = { title, bodyMarkdown: body };
        if (projectId) payload.projectId = projectId;
        const res = await api.request('/api/notes', { method: 'POST', body: payload });
        showToast('Note created successfully!', 'success', 1500);
        try{ localStorage.removeItem(draftKey()); }catch(e){}
        location.href = '/dashboard.html';
      }catch(e){ 
        const errorMsg = e.userMessage || e.error || 'Failed to save note';
        showToast(errorMsg, 'error', 3000);
      }
    }

    // Image upload functionality
    async function uploadImage(file) {
      const maxSize = 5 * 1024 * 1024; // 5MB
      if (file.size > maxSize) {
        showToast('Image must be less than 5MB', 'error', 3000);
        return null;
      }

      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const statusEl = document.getElementById('editor-status');
            statusEl.textContent = 'Uploading image...';
            
            const payload = {
              image: e.target.result,
              filename: file.name,
              noteId: noteId || null
            };
            
            const res = await api.request('/api/uploads/images', { 
              method: 'POST', 
              body: payload 
            });
            
            statusEl.textContent = 'Ready';
            showToast('Image uploaded successfully!', 'success', 1500);
            resolve(res);
          } catch (err) {
            const statusEl = document.getElementById('editor-status');
            statusEl.textContent = 'Ready';
            const errorMsg = err.userMessage || err.error || 'Failed to upload image';
            showToast(errorMsg, 'error', 3000);
            reject(err);
          }
        };
        reader.onerror = () => {
          showToast('Failed to read image file', 'error', 3000);
          reject(new Error('File read error'));
        };
        reader.readAsDataURL(file);
      });
    }

    function insertImageMarkdown(imageUrl, filename) {
      const textarea = document.getElementById('note-body');
      const altText = filename.replace(/\.[^/.]+$/, ''); // Remove extension
      const markdown = `![${altText}](${imageUrl})`;
      
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const val = textarea.value;
      
      textarea.value = val.slice(0, start) + markdown + val.slice(end);
      textarea.focus();
      textarea.selectionStart = textarea.selectionEnd = start + markdown.length;
      textarea.dispatchEvent(new Event('input'));
    }

  function wrapSelection(el, before, after){ if(typeof after==='undefined') after=before; const start=el.selectionStart, end=el.selectionEnd; const val=el.value; const selected=val.slice(start,end); el.value = val.slice(0,start)+before+selected+after+val.slice(end); el.focus(); el.selectionStart = start + before.length; el.selectionEnd = end + before.length; el.dispatchEvent(new Event('input')); }
  function prependLine(el, prefix){ const start=el.selectionStart, val=el.value; const lineStart = val.lastIndexOf('\n', start-1)+1; el.value = val.slice(0,lineStart)+prefix+val.slice(lineStart); el.focus(); el.dispatchEvent(new Event('input')); }

    // load marked.js from CDN for markdown preview if not present
    (function(){
      if (window.marked) return init();
      const s = document.createElement('script'); s.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js'; s.onload = init; document.head.appendChild(s);
    })();
  </script>
</body>
</html>
